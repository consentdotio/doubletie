/**
 * ID Generator mixin for the functional API
 *
 * Adds the ability to generate unique, prefixed IDs using the id-generator module.
 * This mixin adds methods for generating custom IDs and optionally auto-generating IDs
 * during insert operations.
 *
 * @module
 */

import type { InsertObject, Selectable } from 'kysely';
import { generateId } from '../id-generator';
import type { ModelFunctions } from '../model';

// Type alias for insert objects or arrays of insert objects
type InsertObjectOrList<TDatabase, TTableName extends keyof TDatabase> =
	| InsertObject<TDatabase, TTableName>
	| Array<InsertObject<TDatabase, TTableName>>;

/**
 * Configuration options for the ID generator mixin
 */
export interface IdGeneratorOptions {
	/**
	 * The prefix to use for generated IDs
	 */
	prefix: string;

	/**
	 * The column name to use for the ID (defaults to model's primary key)
	 */
	idColumn?: string;

	/**
	 * Whether to automatically generate IDs during insert operations
	 */
	autoGenerate?: boolean;
}

/**
 * Enhances a model with ID generation capabilities
 *
 * @typeParam TDatabase - Database schema type
 * @typeParam TTableName - Table name in the database
 * @typeParam TIdColumnName - Name of the ID column
 * @param model - Base model to enhance
 * @param options - ID generation configuration
 * @returns Enhanced model with ID generation methods
 *
 * @example
 * ```typescript
 * const UserModel = pipe(
 *   model => withIdGenerator(model, { prefix: 'user', autoGenerate: true })
 * )(createModel(db, 'users', 'id'));
 *
 * // Generate a single ID
 * const id = UserModel.generateId();  // "user_3hK4G..."
 *
 * // Insert with auto-generated ID
 * const user = await UserModel.insert({ name: 'John' });
 * ```
 */
export default function withIdGenerator<
	TDatabase extends Record<string, any> = any,
	TTableName extends keyof TDatabase & string = string,
	TIdField extends keyof TDatabase[TTableName] & string = string,
>(
	model: ModelFunctions<TDatabase, TTableName, TIdField>,
	options: IdGeneratorOptions = { prefix: 'id' }
): ModelFunctions<TDatabase, TTableName, TIdField> & {
	generateId: () => string;
	insertWithGeneratedId: (
		data: Omit<InsertObjectOrList<TDatabase, TTableName>, TIdField>
	) => Promise<Selectable<TDatabase[TTableName]>>;
	isGeneratedId: (id: string) => boolean;
} {
	// Determine the ID column to use (default to model's primary key)
	const idColumn = options.idColumn || model.id;

	// Default auto-generate to false
	const autoGenerate = options.autoGenerate ?? false;

	// Save the original processDataBeforeInsert
	const originalProcessDataBeforeInsert = model.processDataBeforeInsert;

	return {
		...model,

		/**
		 * Generates a unique ID with the configured prefix
		 *
		 * @returns A unique, prefixed identifier
		 */
		generateId(): string {
			return generateId(options.prefix);
		},

		/**
		 * Processes data before insert, optionally adding an ID
		 *
		 * @param data - The data to process
		 * @returns The processed data
		 */
		processDataBeforeInsert(data: InsertObjectOrList<TDatabase, TTableName>) {
			// Process with original method first
			let processedData = originalProcessDataBeforeInsert(data);

			// If auto-generate is enabled, add IDs to records that don't have them
			if (autoGenerate) {
				if (Array.isArray(processedData)) {
					// Handle array of objects
					processedData = processedData.map((item) => {
						if (item[idColumn as keyof typeof item] === undefined) {
							return {
								...item,
								[idColumn]: generateId(options.prefix),
							};
						}
						return item;
					});
				}

				// Handle single object
				if (
					processedData[idColumn as keyof typeof processedData] === undefined
				) {
					processedData = {
						...processedData,
						[idColumn]: generateId(options.prefix),
					};
				}
			}

			return processedData;
		},

		/**
		 * Inserts data with an auto-generated ID
		 *
		 * @param data - The data to insert (without ID)
		 * @returns The inserted record
		 */
		async insertWithGeneratedId(
			data: Omit<InsertObjectOrList<TDatabase, TTableName>, TIdField>
		) {
			// Generate a unique ID
			const id = generateId(options.prefix);

			// Add the ID to the data
			const dataWithId = {
				...(data as any),
				[idColumn]: id,
			};

			// Insert using the model's insertInto method
			const result = await model
				.insertInto()
				.values(dataWithId)
				.executeTakeFirst();

			return result as Selectable<TDatabase[TTableName]>;
		},

		/**
		 * Checks if an ID was generated by this mixin
		 *
		 * @param id - The ID to check
		 * @returns True if the ID matches the configured prefix pattern
		 */
		isGeneratedId(id: string): boolean {
			return typeof id === 'string' && id.startsWith(`${options.prefix}_`);
		},
	};
}

// Add default export to match import pattern
export { withIdGenerator };
